-------------------------------------------------------------------------------
mount-cifs-clean-up-indentatio
-------------------------------------------------------------------------------
mount.cifs: clean up indentation in mount.cifs.c

From: Jeff Layton <jlayton@redhat.com>

Use a "goto mount_exit" to make this match later versions better.

Signed-off-by: Jeff Layton <jlayton@redhat.com>
---

 source/client/mount.cifs.c |  101 ++++++++++++++++++++++----------------------
 1 files changed, 51 insertions(+), 50 deletions(-)


diff --git a/source/client/mount.cifs.c b/source/client/mount.cifs.c
index 25f0b9e..3241594 100755
--- a/source/client/mount.cifs.c
+++ b/source/client/mount.cifs.c
@@ -1649,59 +1649,60 @@ mount_retry:
 		}
 		printf("Refer to the mount.cifs(8) manual page (e.g.man mount.cifs)\n");
 		rc = EX_FAIL;
-	} else {
-		atexit(unlock_mtab);
-		rc = lock_mtab();
-		if (rc) {
-			printf("cannot lock mtab");
-			goto mount_exit;
-		}
-		pmntfile = setmntent(MOUNTED, "a+");
-		if (!pmntfile) {
-			printf("could not update mount table\n");
-			unlock_mtab();
-			rc = EX_FILEIO;
-			goto mount_exit;
-		}
-		mountent.mnt_fsname = dev_name;
-		mountent.mnt_dir = mountpoint;
-		mountent.mnt_type = CONST_DISCARD(char *,"cifs");
-		mountent.mnt_opts = (char *)malloc(220);
-		if(mountent.mnt_opts) {
-			char * mount_user = getusername();
-			memset(mountent.mnt_opts,0,200);
-			if(flags & MS_RDONLY)
-				strlcat(mountent.mnt_opts,"ro",220);
-			else
-				strlcat(mountent.mnt_opts,"rw",220);
-			if(flags & MS_MANDLOCK)
-				strlcat(mountent.mnt_opts,",mand",220);
-			if(flags & MS_NOEXEC)
-				strlcat(mountent.mnt_opts,",noexec",220);
-			if(flags & MS_NOSUID)
-				strlcat(mountent.mnt_opts,",nosuid",220);
-			if(flags & MS_NODEV)
-				strlcat(mountent.mnt_opts,",nodev",220);
-			if(flags & MS_SYNCHRONOUS)
-				strlcat(mountent.mnt_opts,",sync",220);
-			if(mount_user) {
-				if(getuid() != 0) {
-					strlcat(mountent.mnt_opts,
-						",user=", 220);
-					strlcat(mountent.mnt_opts,
-						mount_user, 220);
-				}
+		goto mount_exit;
+	}
+
+	atexit(unlock_mtab);
+	rc = lock_mtab();
+	if (rc) {
+		printf("cannot lock mtab");
+		goto mount_exit;
+	}
+	pmntfile = setmntent(MOUNTED, "a+");
+	if (!pmntfile) {
+		printf("could not update mount table\n");
+		unlock_mtab();
+		rc = EX_FILEIO;
+		goto mount_exit;
+	}
+	mountent.mnt_fsname = dev_name;
+	mountent.mnt_dir = mountpoint;
+	mountent.mnt_type = CONST_DISCARD(char *,"cifs");
+	mountent.mnt_opts = (char *)malloc(220);
+	if(mountent.mnt_opts) {
+		char * mount_user = getusername();
+		memset(mountent.mnt_opts,0,200);
+		if(flags & MS_RDONLY)
+			strlcat(mountent.mnt_opts,"ro",220);
+		else
+			strlcat(mountent.mnt_opts,"rw",220);
+		if(flags & MS_MANDLOCK)
+			strlcat(mountent.mnt_opts,",mand",220);
+		if(flags & MS_NOEXEC)
+			strlcat(mountent.mnt_opts,",noexec",220);
+		if(flags & MS_NOSUID)
+			strlcat(mountent.mnt_opts,",nosuid",220);
+		if(flags & MS_NODEV)
+			strlcat(mountent.mnt_opts,",nodev",220);
+		if(flags & MS_SYNCHRONOUS)
+			strlcat(mountent.mnt_opts,",sync",220);
+		if(mount_user) {
+			if(getuid() != 0) {
+				strlcat(mountent.mnt_opts,
+					",user=", 220);
+				strlcat(mountent.mnt_opts,
+					mount_user, 220);
 			}
 		}
-		mountent.mnt_freq = 0;
-		mountent.mnt_passno = 0;
-		rc = addmntent(pmntfile,&mountent);
-		endmntent(pmntfile);
-		unlock_mtab();
-		SAFE_FREE(mountent.mnt_opts);
-		if (rc)
-			rc = EX_FILEIO;
 	}
+	mountent.mnt_freq = 0;
+	mountent.mnt_passno = 0;
+	rc = addmntent(pmntfile,&mountent);
+	endmntent(pmntfile);
+	unlock_mtab();
+	SAFE_FREE(mountent.mnt_opts);
+	if (rc)
+		rc = EX_FILEIO;
 mount_exit:
 	if(mountpassword) {
 		int len = strlen(mountpassword);
-------------------------------------------------------------------------------
mount-cifs-guard-against-signa
-------------------------------------------------------------------------------
mount.cifs: guard against signals by unprivileged users

From: Jeff Layton <jlayton@redhat.com>

If mount.cifs is setuid root, then the unprivileged user who runs the
program can send the mount.cifs process a signal and kill it. This is
not a huge problem unless we happen to be updating the mtab at the
time, in which case the mtab lockfiles might not get cleaned up.

To remedy this, have the privileged mount.cifs process set its real
uid to the effective uid (usually, root). This prevents unprivileged
users from being able to signal the process.

While we're at it, also mask off signals while we're updating the
mtab. This leaves a SIGKILL by root as the only way to interrupt the
mtab update, but there's really nothing we can do about that.

Signed-off-by: Jeff Layton <jlayton@redhat.com>
---

 source/client/mount.cifs.c |   43 +++++++++++++++++++++++++++++++++++++++----
 1 files changed, 39 insertions(+), 4 deletions(-)
 mode change 100755 => 100644 source/client/mount.cifs.c


diff --git a/source/client/mount.cifs.c b/source/client/mount.cifs.c
old mode 100755
new mode 100644
index 3241594..5459b44
--- a/source/client/mount.cifs.c
+++ b/source/client/mount.cifs.c
@@ -42,6 +42,7 @@
 #include <limits.h>
 #include <fstab.h>
 #include "mount.h"
+#include <signal.h>
 
 #define MOUNT_CIFS_VERSION_MAJOR "1"
 #define MOUNT_CIFS_VERSION_MINOR "12RH"
@@ -322,9 +323,9 @@ static void mount_cifs_usage(void)
 }
 
 /* caller frees username if necessary */
-static char * getusername(void) {
+static char * getusername(uid_t uid) {
 	char *username = NULL;
-	struct passwd *password = getpwuid(getuid());
+	struct passwd *password = getpwuid(uid);
 
 	if (password) {
 		username = password->pw_name;
@@ -1222,6 +1223,7 @@ int main(int argc, char ** argv)
 	char * resolved_path = NULL;
 	char * temp;
 	char * dev_name;
+	char * mount_user = NULL;
 	int rc;
 	int rsize = 0;
 	int wsize = 0;
@@ -1235,6 +1237,7 @@ int main(int argc, char ** argv)
 	struct utsname sysinfo;
 	struct mntent mountent;
 	FILE * pmntfile;
+	sigset_t mask, oldmask;
 
 	if (check_setuid())
 		return EX_USAGE;
@@ -1514,7 +1517,7 @@ int main(int argc, char ** argv)
 	mountpoint = resolved_path; 
 
 	if(got_user == 0) {
-		user_name = getusername();
+		user_name = getusername(getuid());
 		got_user = 1;
 	}
        
@@ -1652,6 +1655,38 @@ mount_retry:
 		goto mount_exit;
 	}
 
+
+	uid = getuid();
+	if (uid != 0)
+		mount_user = getusername(uid);
+
+	/*
+	 * Set the real uid to the effective uid. This prevents unprivileged
+	 * users from sending signals to this process, though ^c on controlling
+	 * terminal should still work.
+	 */
+	rc = setreuid(geteuid(), -1);
+	if (rc != 0) {
+		fprintf(stderr, "Unable to set real uid to effective uid: %s\n",
+				strerror(errno));
+		rc = EX_FILEIO;
+		goto mount_exit;
+	}
+
+	rc = sigfillset(&mask);
+	if (rc) {
+		fprintf(stderr, "Unable to set filled signal mask\n");
+		rc = EX_FILEIO;
+		goto mount_exit;
+	}
+
+	rc = sigprocmask(SIG_SETMASK, &mask, &oldmask);
+	if (rc) {
+		fprintf(stderr, "Unable to make process ignore signals\n");
+		rc = EX_FILEIO;
+		goto mount_exit;
+	}
+
 	atexit(unlock_mtab);
 	rc = lock_mtab();
 	if (rc) {
@@ -1670,7 +1705,6 @@ mount_retry:
 	mountent.mnt_type = CONST_DISCARD(char *,"cifs");
 	mountent.mnt_opts = (char *)malloc(220);
 	if(mountent.mnt_opts) {
-		char * mount_user = getusername();
 		memset(mountent.mnt_opts,0,200);
 		if(flags & MS_RDONLY)
 			strlcat(mountent.mnt_opts,"ro",220);
@@ -1703,6 +1737,7 @@ mount_retry:
 	SAFE_FREE(mountent.mnt_opts);
 	if (rc)
 		rc = EX_FILEIO;
+	sigprocmask(SIG_SETMASK, &oldmask, NULL);
 mount_exit:
 	if(mountpassword) {
 		int len = strlen(mountpassword);
-------------------------------------------------------------------------------
mount-cifs-handle-enospc-efbig
-------------------------------------------------------------------------------
mount.cifs: handle ENOSPC/EFBIG condition properly when altering mtab

From: Jeff Layton <jlayton@redhat.com>

It's possible that when mount.cifs goes to append the mtab that there
won't be enough space to do so, and the mntent won't be appended to the
file in its entirety.

Add a my_endmntent routine that will fflush and then fsync the FILE if
that succeeds. If either fails then it will truncate the file back to
its provided size. It will then call endmntent unconditionally.

Have add_mtab call fstat on the opened mtab file in order to get the
size of the file before it has been appended. Assuming that that
succeeds, use my_endmntent to ensure that the file is not corrupted
before closing it. It's possible that we'll have a small race window
where the mtab is incorrect, but it should be quickly corrected.

This was reported some time ago as CVE-2011-1678:

    http://openwall.com/lists/oss-security/2011/03/04/9

...and it seems to fix the reproducer that I was able to come up with.

Signed-off-by: Jeff Layton <jlayton@samba.org>
Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
---

 source/client/mount.cifs.c |   30 ++++++++++++++++++++++++++++--
 source/client/mount.h      |    1 +
 source/client/mtab.c       |   28 ++++++++++++++++++++++++++++
 3 files changed, 57 insertions(+), 2 deletions(-)


diff --git a/source/client/mount.cifs.c b/source/client/mount.cifs.c
index 5459b44..74d39fb 100644
--- a/source/client/mount.cifs.c
+++ b/source/client/mount.cifs.c
@@ -1232,10 +1232,12 @@ int main(int argc, char ** argv)
 	int gid = 0;
 	int optlen = 0;
 	int orgoptlen = 0;
+	int fd, tmprc;
 	size_t options_size = 0;
 	int retry = 0; /* set when we have to retry mount with uppercase */
 	struct utsname sysinfo;
 	struct mntent mountent;
+	struct stat statbuf;
 	FILE * pmntfile;
 	sigset_t mask, oldmask;
 
@@ -1700,6 +1702,22 @@ mount_retry:
 		rc = EX_FILEIO;
 		goto mount_exit;
 	}
+	fd = fileno(pmntfile);
+	if (fd < 0) {
+		fprintf(stderr, "mntent does not appear to be valid\n");
+		unlock_mtab();
+		rc = EX_FILEIO;
+		goto mount_exit;
+	}
+	rc = fstat(fd, &statbuf);
+	if (rc != 0) {
+		fprintf(stderr, "unable to fstat open mtab\n");
+		endmntent(pmntfile);
+		unlock_mtab();
+		rc = EX_FILEIO;
+		goto mount_exit;
+	}
+
 	mountent.mnt_fsname = dev_name;
 	mountent.mnt_dir = mountpoint;
 	mountent.mnt_type = CONST_DISCARD(char *,"cifs");
@@ -1731,8 +1749,16 @@ mount_retry:
 	}
 	mountent.mnt_freq = 0;
 	mountent.mnt_passno = 0;
-	rc = addmntent(pmntfile,&mountent);
-	endmntent(pmntfile);
+	rc = addmntent(pmntfile, &mountent);
+	if (rc) {
+		fprintf(stderr, "unable to add mount entry to mtab\n");
+		ftruncate(fd, statbuf.st_size);
+	}
+	tmprc = my_endmntent(pmntfile, statbuf.st_size);
+	if (tmprc) {
+		fprintf(stderr, "error %d detected on close of mtab\n", tmprc);
+		rc = EX_FILEIO;
+	}
 	unlock_mtab();
 	SAFE_FREE(mountent.mnt_opts);
 	if (rc)
diff --git a/source/client/mount.h b/source/client/mount.h
index 6070489..dd929d3 100644
--- a/source/client/mount.h
+++ b/source/client/mount.h
@@ -34,5 +34,6 @@
 
 extern int lock_mtab(void);
 extern void unlock_mtab(void);
+extern int my_endmntent(FILE *stream, off_t size);
 
 #endif /* ! _MOUNT_H_ */
diff --git a/source/client/mtab.c b/source/client/mtab.c
index 569862f..5237ff7 100644
--- a/source/client/mtab.c
+++ b/source/client/mtab.c
@@ -217,3 +218,30 @@ lock_mtab (void) {
 	return 0;
 }
 
+/*
+ * Call fflush and fsync on the mtab, and then endmntent. If either fflush
+ * or fsync fails, then truncate the file back to "size". endmntent is called
+ * unconditionally, and the errno (if any) from fflush and fsync are returned.
+ */
+int
+my_endmntent(FILE *stream, off_t size)
+{
+	int rc, fd;
+
+	fd = fileno(stream);
+	if (fd < 0)
+		return -EBADF;
+
+	rc = fflush(stream);
+	if (!rc)
+		rc = fsync(fd);
+
+	/* truncate file back to "size" -- best effort here */
+	if (rc) {
+		rc = errno;
+		ftruncate(fd, size);
+	}
+
+	endmntent(stream);
+	return rc;
+}
