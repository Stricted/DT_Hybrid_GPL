diff --git a/source/client/client.c b/source/client/client.c
index e87623a..2bbc12a 100644
--- a/source/client/client.c
+++ b/source/client/client.c
@@ -3611,8 +3611,10 @@ static void readline_callback(void)
 
  again:
 
-	if (cli->fd == -1)
+	if (cli->fd < 0 || cli->fd >= FD_SETSIZE) {
+		errno = EBADF;
 		return;
+	}
 
 	FD_ZERO(&fds);
 	FD_SET(cli->fd,&fds);
diff --git a/source/client/smbctool.c b/source/client/smbctool.c
index a18505b..c38ea48 100644
--- a/source/client/smbctool.c
+++ b/source/client/smbctool.c
@@ -3289,8 +3289,10 @@ static void readline_callback(void)
 
  again:
 
-	if (cli->fd == -1)
+	if (cli->fd < 0 || cli->fd >= FD_SETSIZE) {
+		errno = EBADF;
 		return;
+	}
 
 	FD_ZERO(&fds);
 	FD_SET(cli->fd,&fds);
diff --git a/source/lib/events.c b/source/lib/events.c
index fadb15e..c2e6d17 100644
--- a/source/lib/events.c
+++ b/source/lib/events.c
@@ -153,6 +153,11 @@ struct fd_event *event_add_fd(struct event_context *event_ctx,
 {
 	struct fd_event *fde;
 
+	if (fd < 0 || fd >= FD_SETSIZE) {
+		errno = EBADF;
+		return NULL;
+	}
+
 	if (!(fde = TALLOC_P(mem_ctx, struct fd_event))) {
 		return NULL;
 	}
@@ -198,6 +203,14 @@ void event_add_to_select_args(struct event_context *event_ctx,
 	struct timeval diff;
 
 	for (fde = event_ctx->fd_events; fde; fde = fde->next) {
+		if (fde->fd < 0 || fde->fd >= FD_SETSIZE) {
+			/* We ignore here, as it shouldn't be
+			   possible to add an invalid fde->fd
+			   but we don't want FD_SET to see an
+			   invalid fd. */
+			continue;
+		}
+
 		if (fde->flags & EVENT_FD_READ) {
 			FD_SET(fde->fd, read_fds);
 		}
diff --git a/source/lib/readline.c b/source/lib/readline.c
index 24d16ea..90d06be 100644
--- a/source/lib/readline.c
+++ b/source/lib/readline.c
@@ -69,6 +69,11 @@ static char *smb_readline_replacement(const char *prompt, void (*callback)(void)
 		timeout.tv_sec = 5;
 		timeout.tv_usec = 0;
 
+		if (fd < 0 || fd >= FD_SETSIZE) {
+			errno = EBADF;
+			break;
+		}
+
 		FD_ZERO(&fds);
 		FD_SET(fd,&fds);
 	
@@ -79,6 +84,7 @@ static char *smb_readline_replacement(co
 		if (callback)
 			callback();
 	}
+	return NULL;
 }
 
 /****************************************************************************
diff --git a/source/lib/select.c b/source/lib/select.c
index f63221f..13bf29c 100644
--- a/source/lib/select.c
+++ b/source/lib/select.c
@@ -61,6 +61,11 @@ int sys_select(int maxfd, fd_set *readfds, fd_set *writefds, fd_set *errorfds, s
 	if (initialised != sys_getpid()) {
 		pipe(select_pipe);
 
+		if (select_pipe[0] < 0 || select_pipe[0] >= FD_SETSIZE) {
+			errno = EBADF;
+			return -1;
+		}
+
 		/*
 		 * These next two lines seem to fix a bug with the Linux
 		 * 2.0.x kernel (and probably other UNIXes as well) where
diff --git a/source/lib/util_sock.c b/source/lib/util_sock.c
index 4715ca7..158d95e 100644
--- a/source/lib/util_sock.c
+++ b/source/lib/util_sock.c
@@ -452,6 +452,12 @@ ssize_t read_socket_with_timeout(int fd,char *buf,size_t mincnt,size_t maxcnt,un
 	timeout.tv_usec = (long)(1000 * (time_out % 1000));
 	
 	for (nread=0; nread < mincnt; ) {      
+		if (fd < 0 || fd >= FD_SETSIZE) {
+			errno = EBADF;
+			smb_read_error = READ_ERROR;
+			return -1;
+		}
+
 		FD_ZERO(&fds);
 		FD_SET(fd,&fds);
 		
@@ -944,7 +950,7 @@ BOOL open_any_socket_out(struct sockaddr_in *addrs, int num_addrs,
 
 	for (i=0; i<num_addrs; i++) {
 		sockets[i] = socket(PF_INET, SOCK_STREAM, 0);
-		if (sockets[i] < 0)
+		if (sockets[i] < 0 || sockets[i] >= FD_SETSIZE)
 			goto done;
 		set_blocking(sockets[i], False);
 	}
@@ -992,8 +998,10 @@ BOOL open_any_socket_out(struct sockaddr_in *addrs, int num_addrs,
 	FD_ZERO(&r_fds);
 
 	for (i=0; i<num_addrs; i++) {
-		if (sockets[i] == -1)
+		if (sockets[i] < 0 || sockets[i] >= FD_SETSIZE) {
+			/* This cannot happen - ignore if so. */
 			continue;
+		}
 		FD_SET(sockets[i], &wr_fds);
 		FD_SET(sockets[i], &r_fds);
 		if (sockets[i]>maxfd)
@@ -1012,9 +1020,9 @@ BOOL open_any_socket_out(struct sockaddr_in *addrs, int num_addrs,
 		goto next_round;
 
 	for (i=0; i<num_addrs; i++) {
-
-		if (sockets[i] == -1)
+		if (sockets[i] < 0 || sockets[i] >= FD_SETSIZE) {
 			continue;
+		}
 
 		/* Stevens, Network Programming says that if there's a
 		 * successful connect, the socket is only writable. Upon an
diff --git a/source/libaddns/dnssock.c b/source/libaddns/dnssock.c
index 6ceefb4..00b8db2 100644
--- a/source/libaddns/dnssock.c
+++ b/source/libaddns/dnssock.c
@@ -219,7 +219,11 @@ static DNS_ERROR read_all(int fd, uint8 *data, size_t len)
 	while (total < len) {
 		ssize_t ret;
 		int fd_ready;
-		
+
+		if (fd < 0 || fd >= FD_SETSIZE) {
+			return ERROR_DNS_SOCKET_ERROR;
+		}
+
 		FD_ZERO( &rfds );
 		FD_SET( fd, &rfds );
 
diff --git a/source/libsmb/nmblib.c b/source/libsmb/nmblib.c
index 641473b..97ff61f 100644
--- a/source/libsmb/nmblib.c
+++ b/source/libsmb/nmblib.c
@@ -1011,6 +1011,11 @@ struct packet_struct *receive_packet(int fd,enum packet_type type,int t)
 	struct timeval timeout;
 	int ret;
 
+	if (fd < 0 || fd >= FD_SETSIZE) {
+		errno = EBADF;
+		return NULL;
+	}
+
 	FD_ZERO(&fds);
 	FD_SET(fd,&fds);
 	timeout.tv_sec = t/1000;
diff --git a/source/nmbd/nmbd_packets.c b/source/nmbd/nmbd_packets.c
index 97a81fe..52133f6 100644
--- a/source/nmbd/nmbd_packets.c
+++ b/source/nmbd/nmbd_packets.c
@@ -1678,7 +1678,7 @@ static BOOL create_listen_fdset(fd_set **ppset, int **psock_array, int *listen_n
 	for (subrec = FIRST_SUBNET; subrec; subrec = NEXT_SUBNET_EXCLUDING_UNICAST(subrec))
 		count++;
 
-	if((count*2) + 2 > FD_SETSIZE) {
+	if((count*2) + 2 >= FD_SETSIZE) {
 		DEBUG(0,("create_listen_fdset: Too many file descriptors needed (%d). We can \
 only use %d.\n", (count*2) + 2, FD_SETSIZE));
 		SAFE_FREE(pset);
@@ -1694,24 +1694,44 @@ only use %d.\n", (count*2) + 2, FD_SETSIZE));
 	FD_ZERO(pset);
 
 	/* Add in the broadcast socket on 137. */
+	if (ClientNMB < 0 || ClientNMB >= FD_SETSIZE) {
+		errno = EBADF;
+		SAFE_FREE(pset);
+		return True;
+	}
+
 	FD_SET(ClientNMB,pset);
 	sock_array[num++] = ClientNMB;
 	*maxfd = MAX( *maxfd, ClientNMB);
 
 	/* Add in the 137 sockets on all the interfaces. */
 	for (subrec = FIRST_SUBNET; subrec; subrec = NEXT_SUBNET_EXCLUDING_UNICAST(subrec)) {
+		if (subrec->nmb_sock < 0 || subrec->nmb_sock >= FD_SETSIZE) {
+			/* We have to ignore sockets outside FD_SETSIZE. */
+			continue;
+		}
 		FD_SET(subrec->nmb_sock,pset);
 		sock_array[num++] = subrec->nmb_sock;
 		*maxfd = MAX( *maxfd, subrec->nmb_sock);
 	}
 
 	/* Add in the broadcast socket on 138. */
+	if (ClientDGRAM < 0 || ClientDGRAM >= FD_SETSIZE) {
+		errno = EBADF;
+		SAFE_FREE(pset);
+		return True;
+	}
+
 	FD_SET(ClientDGRAM,pset);
 	sock_array[num++] = ClientDGRAM;
 	*maxfd = MAX( *maxfd, ClientDGRAM);
 
 	/* Add in the 138 sockets on all the interfaces. */
 	for (subrec = FIRST_SUBNET; subrec; subrec = NEXT_SUBNET_EXCLUDING_UNICAST(subrec)) {
+		if (subrec->dgram_sock < 0 || subrec->dgram_sock >= FD_SETSIZE) {
+			/* We have to ignore sockets outside FD_SETSIZE. */
+			continue;
+		}
 		FD_SET(subrec->dgram_sock,pset);
 		sock_array[num++] = subrec->dgram_sock;
 		*maxfd = MAX( *maxfd, subrec->dgram_sock);
@@ -1760,7 +1780,7 @@ BOOL listen_for_packets(BOOL run_election)
 
 #ifndef SYNC_DNS
 	dns_fd = asyncdns_fd();
-	if (dns_fd != -1) {
+	if (dns_fd != -1 && dns_fd < FD_SETSIZE) {
 		FD_SET(dns_fd, &fds);
 		maxfd = MAX( maxfd, dns_fd);
 	}
diff --git a/source/nsswitch/wb_common.c b/source/nsswitch/wb_common.c
index bae54f2..401adb9 100644
--- a/source/nsswitch/wb_common.c
+++ b/source/nsswitch/wb_common.c
@@ -249,6 +249,12 @@ static int winbind_named_pipe_sock(const char *dir)
 
 		switch (errno) {
 			case EINPROGRESS:
+
+				if (fd < 0 || fd >= FD_SETSIZE) {
+					errno = EBADF;
+					goto error_out;
+				}
+
 				FD_ZERO(&w_fds);
 				FD_SET(fd, &w_fds);
 				tv.tv_sec = CONNECT_TIMEOUT - wait_time;
@@ -378,7 +384,13 @@ int write_sock(void *buffer, int count, int recursing, int need_priv)
 	while(nwritten < count) {
 		struct timeval tv;
 		fd_set r_fds;
-		
+
+		if (winbindd_fd < 0 || winbindd_fd >= FD_SETSIZE) {
+			errno = EBADF;
+			close_sock();
+			return -1;
+		}
+
 		/* Catch pipe close on other end by checking if a read()
 		   call would not block by calling select(). */
 
@@ -430,7 +442,8 @@ static int read_sock(void *buffer, int count)
 	int nread = 0;
 	int total_time = 0, selret;
 
-	if (winbindd_fd == -1) {
+	if (winbindd_fd < 0 || winbindd_fd >= FD_SETSIZE) {
+		errno = EBADF;
 		return -1;
 	}
 
diff --git a/source/nsswitch/winbindd.c b/source/nsswitch/winbindd.c
index 48b94f2..ac6aa8c 100644
--- a/source/nsswitch/winbindd.c
+++ b/source/nsswitch/winbindd.c
@@ -772,7 +772,8 @@ static void process_loop(void)
 	listen_sock = open_winbindd_socket();
 	listen_priv_sock = open_winbindd_priv_socket();
 
-	if (listen_sock == -1 || listen_priv_sock == -1) {
+	if (listen_sock < 0 || listen_sock >= FD_SETSIZE ||
+			listen_priv_sock < 0 || listen_priv_sock >= FD_SETSIZE) {
 		perror("open_winbind_socket");
 		exit(1);
 	}
@@ -798,6 +799,9 @@ static void process_loop(void)
 
 	maxfd = MAX(listen_sock, listen_priv_sock);
 
+	/* We check the range for listen_sock and
+	   listen_priv_sock above. */
+
 	FD_ZERO(&r_fds);
 	FD_ZERO(&w_fds);
 	FD_SET(listen_sock, &r_fds);
@@ -829,6 +833,12 @@ static void process_loop(void)
 	}
 
 	for (ev = fd_events; ev; ev = ev->next) {
+		if (ev->fd < 0 || ev->fd >= FD_SETSIZE) {
+			/* Ignore here - event_add_to_select_args
+			   should make this impossible. */
+			continue;
+		}
+
 		if (ev->flags & EVENT_FD_READ) {
 			FD_SET(ev->fd, &r_fds);
 			maxfd = MAX(ev->fd, maxfd);
diff --git a/source/nsswitch/winbindd_dual.c b/source/nsswitch/winbindd_dual.c
index f976eba..2e3abe2 100644
--- a/source/nsswitch/winbindd_dual.c
+++ b/source/nsswitch/winbindd_dual.c
@@ -988,6 +988,12 @@ static BOOL fork_domain_child(struct winbindd_child *child)
 		return False;
 	}
 
+	if (fdpair[0] < 0 || fdpair[0] >= FD_SETSIZE) {
+		DEBUG(0, ("fork_domain_child: bad fd range (%d)\n", fdpair[0]));
+		errno = EBADF;
+		return False;
+	}
+
 	ZERO_STRUCT(state);
 	state.pid = sys_getpid();
 
@@ -1130,6 +1136,7 @@ static BOOL fork_domain_child(struct winbindd_child *child)
 		message_dispatch();
 
 		FD_ZERO(&read_fds);
+		/* We check state.sock against FD_SETSIZE above. */
 		FD_SET(state.sock, &read_fds);
 
 		ret = sys_select(state.sock + 1, &read_fds, NULL, NULL, tp);
diff --git a/source/smbd/oplock.c b/source/smbd/oplock.c
index 54c9492..60ddfb7 100644
--- a/source/smbd/oplock.c
+++ b/source/smbd/oplock.c
@@ -240,7 +240,10 @@ BOOL downgrade_oplock(files_struct *fsp)
 int oplock_notify_fd(void)
 {
 	if (koplocks) {
-		return koplocks->notification_fd;
+		int fd = koplocks->notification_fd;
+		if (fd < 0 || fd >= FD_SETSIZE) {
+			return -1;
+		}
 	}
 
 	return -1;
diff --git a/source/smbd/oplock_irix.c b/source/smbd/oplock_irix.c
index c1159cd..b822cb8 100644
--- a/source/smbd/oplock_irix.c
+++ b/source/smbd/oplock_irix.c
@@ -247,6 +247,7 @@ static BOOL irix_oplock_msg_waiting(fd_set *fds)
 	 * we need to ignore any signals. */
 
 	FD_ZERO(&myfds);
+	/* We check oplock_pipe_read is in the correct range below. */
 	FD_SET(oplock_pipe_read, &myfds);
 
 	to = timeval_set(0, 0);
@@ -272,6 +273,11 @@ struct kernel_oplocks *irix_init_kernel_oplocks(void)
 		return False;
 	}
 
+	if (pfd[0] < 0 || pfd[0] >= FD_SETSIZE) {
+		DEBUG(0,("setup_kernel_oplock_pipe: fd out of range.\n"));
+		return False;
+	}
+
 	oplock_pipe_read = pfd[0];
 	oplock_pipe_write = pfd[1];
 
diff --git a/source/smbd/process.c b/source/smbd/process.c
index e861e16..a81d169 100644
--- a/source/smbd/process.c
+++ b/source/smbd/process.c
@@ -320,7 +320,7 @@ static void async_processing(fd_set *pfds)
 
 static int select_on_fd(int fd, int maxfd, fd_set *fds)
 {
-	if (fd != -1) {
+	if (fd != -1 && fd < FD_SETSIZE) {
 		FD_SET(fd, fds);
 		maxfd = MAX(maxfd, fd);
 	}
diff --git a/source/smbd/server.c b/source/smbd/server.c
index 9f13c32..de3e5b1 100644
--- a/source/smbd/server.c
+++ b/source/smbd/server.c
@@ -184,7 +184,13 @@ static BOOL open_sockets_inetd(void)
 	/* Started from inetd. fd 0 is the socket. */
 	/* We will abort gracefully when the client or remote system 
 	   goes away */
-	smbd_set_server_fd(dup(0));
+	int fd = dup(0);
+
+	if (fd < 0 || fd >= FD_SETSIZE) {
+		return false;
+	}
+
+	smbd_set_server_fd(fd);
 	
 	/* close our standard file descriptors */
 	close_low_fds(False); /* Don't close stderr */
@@ -371,8 +377,9 @@ static BOOL open_sockets_smbd(BOOL is_daemon, BOOL interactive, const char *smb_
 					continue;
 				}
 				s = fd_listenset[num_sockets] = open_socket_in(SOCK_STREAM, port, 0, ifip->s_addr, True);
-				if(s == -1)
+				if (s < 0 || s >= FD_SETSIZE) {
 					return False;
+				}
 
 				/* ready to listen */
 				set_socket_options(s,"SO_KEEPALIVE"); 
@@ -411,8 +418,9 @@ static BOOL open_sockets_smbd(BOOL is_daemon, BOOL interactive, const char *smb_
 			/* open an incoming socket */
 			s = open_socket_in(SOCK_STREAM, port, 0,
 					   interpret_addr(lp_socket_address()),True);
-			if (s == -1)
-				return(False);
+			if (s < 0 || s >= FD_SETSIZE) {
+				return False;
+			}
 		
 			/* ready to listen */
 			set_socket_options(s,"SO_KEEPALIVE"); 
@@ -509,6 +517,7 @@ static BOOL open_sockets_smbd(BOOL is_daemon, BOOL interactive, const char *smb_
 			struct sockaddr addr;
 			socklen_t in_addrlen = sizeof(addr);
 			pid_t child = 0;
+			int fd;
 
 			s = -1;
 			for(i = 0; i < num_sockets; i++) {
@@ -521,17 +530,22 @@ static BOOL open_sockets_smbd(BOOL is_daemon, BOOL interactive, const char *smb_
 				}
 			}
 
-			smbd_set_server_fd(accept(s,&addr,&in_addrlen));
-			
-			if (smbd_server_fd() == -1 && errno == EINTR)
+			fd = accept(s,&addr,&in_addrlen);
+			if (fd == -1 && errno == EINTR)
 				continue;
-			
-			if (smbd_server_fd() == -1) {
+			if (fd == -1) {
 				DEBUG(0,("open_sockets_smbd: accept: %s\n",
 					 strerror(errno)));
 				continue;
 			}
+			if (fd < 0 || fd >= FD_SETSIZE) {
+				DEBUG(2,("open_sockets_smbd: bad fd %d\n",
+					fd ));
+				continue;
+			}
 
+			smbd_set_server_fd(fd);
+			
 			/* Ensure child is set to blocking mode */
 			set_blocking(smbd_server_fd(),True);
 
diff --git a/source/utils/smbfilter.c b/source/utils/smbfilter.c
index 2152e53..8bad730 100644
--- a/source/utils/smbfilter.c
+++ b/source/utils/smbfilter.c
@@ -133,8 +133,8 @@ static void filter_child(int c, struct in_addr dest_ip)
 		int num;
 		
 		FD_ZERO(&fds);
-		if (s != -1) FD_SET(s, &fds);
-		if (c != -1) FD_SET(c, &fds);
+		if (s >= 0 && s < FD_SETSIZE) FD_SET(s, &fds);
+		if (c >= 0 && c < FD_SETSIZE) FD_SET(c, &fds);
 
 		num = sys_select_intr(MAX(s+1, c+1),&fds,NULL,NULL,NULL);
 		if (num <= 0) continue;
@@ -197,6 +197,10 @@ static void start_filter(char *desthost)
 		struct sockaddr addr;
 		socklen_t in_addrlen = sizeof(addr);
 		
+		if (s < 0 || s >= FD_SETSIZE) {
+			break;
+		}
+
 		FD_ZERO(&fds);
 		FD_SET(s, &fds);
 
